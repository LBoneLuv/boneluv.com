#!/usr/bin/env node
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const sade_1 = tslib_1.__importDefault(require("sade"));
const sync_1 = tslib_1.__importDefault(require("tiny-glob/sync"));
const rollup_1 = require("rollup");
const asyncro_1 = tslib_1.__importDefault(require("asyncro"));
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const util_1 = tslib_1.__importDefault(require("util"));
const fs = tslib_1.__importStar(require("fs-extra"));
const jest_1 = tslib_1.__importDefault(require("jest"));
const logError_1 = tslib_1.__importDefault(require("./logError"));
const path_1 = tslib_1.__importDefault(require("path"));
const mkdirp_1 = tslib_1.__importDefault(require("mkdirp"));
const execa_1 = tslib_1.__importDefault(require("execa"));
const ora_1 = tslib_1.__importDefault(require("ora"));
const constants_1 = require("./constants");
const Messages = tslib_1.__importStar(require("./messages"));
const createRollupConfig_1 = require("./createRollupConfig");
const createJestConfig_1 = require("./createJestConfig");
const utils_1 = require("./utils");
const jpjs_1 = require("jpjs");
const getInstallCmd_1 = tslib_1.__importDefault(require("./getInstallCmd"));
const getInstallArgs_1 = tslib_1.__importDefault(require("./getInstallArgs"));
const enquirer_1 = require("enquirer");
const pkg = require('../package.json');
const createLogger = require('progress-estimator');
// All configuration keys are optional, but it's recommended to specify a storage location.
// Learn more about configuration options below.
const logger = createLogger({
    storagePath: path_1.default.join(__dirname, '.progress-estimator'),
});
const prog = sade_1.default('tsdx');
let appPackageJson;
try {
    appPackageJson = fs.readJSONSync(utils_1.resolveApp('package.json'));
}
catch (e) { }
exports.isDir = (name) => fs
    .stat(name)
    .then(stats => stats.isDirectory())
    .catch(() => false);
exports.isFile = (name) => fs
    .stat(name)
    .then(stats => stats.isFile())
    .catch(() => false);
async function jsOrTs(filename) {
    const extension = (await exports.isFile(utils_1.resolveApp(filename + '.ts')))
        ? '.ts'
        : (await exports.isFile(utils_1.resolveApp(filename + '.tsx')))
            ? '.tsx'
            : '.js';
    return utils_1.resolveApp(`${filename}${extension}`);
}
async function getInputs(entries, source) {
    let inputs = [];
    let stub = [];
    stub
        .concat(entries && entries.length
        ? entries
        : (source && utils_1.resolveApp(source)) ||
            ((await exports.isDir(utils_1.resolveApp('src'))) && (await jsOrTs('src/index'))))
        .map(file => sync_1.default(file))
        .forEach(input => inputs.push(input));
    return jpjs_1.concatAllArray(inputs);
}
function createBuildConfigs(opts) {
    return jpjs_1.concatAllArray(opts.input.map((input) => [
        opts.format.includes('cjs') &&
            createRollupConfig_1.createRollupConfig('cjs', 'development', Object.assign({}, opts, { input })),
        opts.format.includes('cjs') &&
            createRollupConfig_1.createRollupConfig('cjs', 'production', Object.assign({}, opts, { input })),
        opts.format.includes('es') &&
            createRollupConfig_1.createRollupConfig('es', 'production', Object.assign({}, opts, { input })),
        opts.format.includes('umd') &&
            createRollupConfig_1.createRollupConfig('umd', 'development', Object.assign({}, opts, { input })),
        opts.format.includes('umd') &&
            createRollupConfig_1.createRollupConfig('umd', 'production', Object.assign({}, opts, { input })),
    ])).filter(Boolean);
}
async function moveTypes() {
    try {
        // Move the typescript types to the base of the ./dist folder
        await fs.copy(constants_1.paths.appDist + '/src', constants_1.paths.appDist, {
            overwrite: true,
        });
        await fs.remove(constants_1.paths.appDist + '/src');
    }
    catch (e) { }
}
prog
    .version(pkg.version)
    .command('create <pkg>')
    .describe('Create a new package with TSDX')
    .action(async (pkg) => {
    const bootSpinner = ora_1.default(`Creating ${chalk_1.default.bold.green(pkg)}...`);
    let template;
    // Helper fn to prompt the user for a different
    // folder name if one already exists
    async function getProjectPath(projectPath) {
        if (fs.existsSync(projectPath)) {
            bootSpinner.fail(`Failed to create ${chalk_1.default.bold.red(pkg)}`);
            const prompt = new enquirer_1.Input({
                message: `A folder named ${chalk_1.default.bold.red(pkg)} already exists! ${chalk_1.default.bold('Choose a different name')}`,
                initial: pkg + '-1',
                result: (v) => v.trim(),
            });
            pkg = await prompt.run();
            projectPath = fs.realpathSync(process.cwd()) + '/' + pkg;
            bootSpinner.start(`Creating ${chalk_1.default.bold.green(pkg)}...`);
            return getProjectPath(projectPath); // recursion!
        }
        else {
            return projectPath;
        }
    }
    try {
        // get the project path
        let projectPath = await getProjectPath(fs.realpathSync(process.cwd()) + '/' + pkg);
        const prompt = new enquirer_1.Select({
            message: 'Choose a template',
            choices: ['basic', 'react'],
        });
        template = await prompt.run();
        bootSpinner.start();
        // copy the template
        await fs.copy(path_1.default.resolve(__dirname, `../templates/${template}`), projectPath, {
            overwrite: true,
        });
        // fix gitignore
        await fs.move(path_1.default.resolve(projectPath, './gitignore'), path_1.default.resolve(projectPath, './.gitignore'));
        // Install deps
        process.chdir(projectPath);
        const safeName = utils_1.safePackageName(pkg);
        const pkgJson = {
            name: safeName,
            version: '0.1.0',
            main: 'dist/index.js',
            'umd:main': `dist/${safeName}.umd.production.js`,
            module: `dist/${safeName}.es.production.js`,
            typings: 'dist/index.d.ts',
            files: ['dist'],
            scripts: {
                start: 'tsdx watch',
                build: 'tsdx build',
                test: template === 'react' ? 'tsdx test --env=jsdom' : 'tsdx test',
            },
            peerDependencies: template === 'react' ? { react: '>=16' } : {},
            husky: {
                hooks: {
                    'pre-commit': 'pretty-quick --staged',
                },
            },
            prettier: {
                printWidth: 80,
                semi: true,
                singleQuote: true,
                trailingComma: 'es5',
            },
        };
        await fs.outputJSON(path_1.default.resolve(projectPath, 'package.json'), pkgJson);
        bootSpinner.succeed(`Created ${chalk_1.default.bold.green(pkg)}`);
        Messages.start(pkg);
    }
    catch (error) {
        bootSpinner.fail(`Failed to create ${chalk_1.default.bold.red(pkg)}`);
        logError_1.default(error);
        process.exit(1);
    }
    let deps = [
        '@types/jest',
        'husky',
        'pretty-quick',
        'prettier',
        'tsdx',
        'tslib',
        'typescript',
    ].sort();
    if (template === 'react') {
        deps = [
            ...deps,
            '@types/react',
            '@types/react-dom',
            'react',
            'react-dom',
        ].sort();
    }
    const installSpinner = ora_1.default(Messages.installing(deps)).start();
    try {
        const cmd = getInstallCmd_1.default();
        await execa_1.default(cmd, getInstallArgs_1.default(cmd, deps));
        installSpinner.succeed('Installed dependecines');
        console.log(Messages.start(pkg));
    }
    catch (error) {
        installSpinner.fail('Failed to install dependencies');
        logError_1.default(error);
        process.exit(1);
    }
});
prog
    .command('watch')
    .describe('Rebuilds on any change')
    .option('--entry, -i', 'Entry module(s)')
    .example('watch --entry src/foo.tsx')
    .option('--target', 'Specify your target environment', 'web')
    .example('watch --target node')
    .option('--name', 'Specify name exposed in UMD builds')
    .example('watch --name Foo')
    .option('--format', 'Specify module format(s)', 'cjs,es,umd')
    .example('watch --format cjs,es')
    .option('--tsconfig', 'Specify custom tsconfig path')
    .example('build --tsconfig ./tsconfig.foo.json')
    .action(async (opts) => {
    opts.name = opts.name || appPackageJson.name;
    opts.input = await getInputs(opts.entry, appPackageJson.source);
    const [cjsDev, cjsProd, ...otherConfigs] = createBuildConfigs(opts);
    if (opts.format.includes('cjs')) {
        await util_1.default.promisify(mkdirp_1.default)(utils_1.resolveApp('dist'));
        await fs.writeFile(utils_1.resolveApp('dist/index.js'), `
         'use strict'

      if (process.env.NODE_ENV === 'production') {
        module.exports = require('./${utils_1.safePackageName(opts.name)}.cjs.production.js')
      } else {
        module.exports = require('./${utils_1.safePackageName(opts.name)}.cjs.development.js')
      }`);
    }
    const spinner = ora_1.default().start();
    await rollup_1.watch([cjsDev, cjsProd, ...otherConfigs].map(inputOptions => (Object.assign({ watch: {
            silent: true,
            include: 'src/**',
            exclude: 'node_modules/**',
        } }, inputOptions)))).on('event', async (event) => {
        if (event.code === 'START') {
            utils_1.clearConsole();
            spinner.start(chalk_1.default.bold.cyan('Compiling modules...'));
        }
        if (event.code === 'ERROR') {
            spinner.fail(chalk_1.default.bold.red('Failed to compile'));
            logError_1.default(event.error);
        }
        if (event.code === 'FATAL') {
            spinner.fail(chalk_1.default.bold.red('Failed to compile'));
            logError_1.default(event.error);
        }
        if (event.code === 'END') {
            spinner.succeed(chalk_1.default.bold.green('Compiled successfully'));
            console.log(`
  ${chalk_1.default.dim('Watching for changes')}
`);
            try {
                await moveTypes();
            }
            catch (_error) { }
        }
    });
});
prog
    .command('build')
    .describe('Build your project once and exit')
    .option('--entry, -i', 'Entry module(s)')
    .example('build --entry src/foo.tsx')
    .option('--target', 'Specify your target environment', 'web')
    .example('build --target node')
    .option('--name', 'Specify name exposed in UMD builds')
    .example('build --name Foo')
    .option('--format', 'Specify module format(s)', 'cjs,es,umd')
    .example('build --format cjs,es')
    .option('--tsconfig', 'Specify custom tsconfig path')
    .example('build --tsconfig ./tsconfig.foo.json')
    .action(async (opts) => {
    opts.name = opts.name || appPackageJson.name;
    opts.input = await getInputs(opts.entry, appPackageJson.source);
    const [cjsDev, cjsProd, ...otherConfigs] = createBuildConfigs(opts);
    if (opts.format.includes('cjs')) {
        try {
            await util_1.default.promisify(mkdirp_1.default)(utils_1.resolveApp('./dist'));
            const promise = fs
                .writeFile(utils_1.resolveApp('./dist/index.js'), `
         'use strict'

      if (process.env.NODE_ENV === 'production') {
        module.exports = require('./${utils_1.safePackageName(opts.name)}.cjs.production.js')
      } else {
        module.exports = require('./${utils_1.safePackageName(opts.name)}.cjs.development.js')
      }`)
                .catch(e => {
                throw e;
            });
            logger(promise, 'Creating entry file');
        }
        catch (e) {
            logError_1.default(e);
        }
    }
    try {
        const promise = asyncro_1.default
            .map([cjsDev, cjsProd, ...otherConfigs], async (inputOptions) => {
            let bundle = await rollup_1.rollup(inputOptions);
            await bundle.write(inputOptions.output);
            await moveTypes();
        })
            .catch((e) => {
            throw e;
        });
        logger(promise, 'Building modules');
    }
    catch (error) {
        logError_1.default(error);
    }
});
prog
    .command('test')
    .describe('Run jest test runner in watch mode. Passes through all flags directly to Jest')
    .action(async (opts) => {
    // Do this as the first thing so that any code reading it knows the right env.
    process.env.BABEL_ENV = 'test';
    process.env.NODE_ENV = 'test';
    // Makes the script crash on unhandled rejections instead of silently
    // ignoring them. In the future, promise rejections that are not handled will
    // terminate the Node.js process with a non-zero exit code.
    process.on('unhandledRejection', err => {
        throw err;
    });
    const argv = process.argv.slice(2);
    argv.push('--config', JSON.stringify(Object.assign({}, createJestConfig_1.createJestConfig(relativePath => path_1.default.resolve(__dirname, '..', relativePath), constants_1.paths.appRoot), appPackageJson.jest)));
    const [_skipTheWordTest, ...argsToPassToJestCli] = argv;
    jest_1.default.run(argsToPassToJestCli);
});
prog.parse(process.argv);
