(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('gotrue-js')) :
  typeof define === 'function' && define.amd ? define(['exports', 'react', 'gotrue-js'], factory) :
  (global = global || self, factory(global['react-netlify-identity'] = {}, global.React, global.GoTrue));
}(this, function (exports, React, GoTrue) { 'use strict';

  React = React && React.hasOwnProperty('default') ? React['default'] : React;
  GoTrue = GoTrue && GoTrue.hasOwnProperty('default') ? GoTrue['default'] : GoTrue;

  /**
   * This code runs on every rerender so keep it light
   * keep checking the current route and do logic based on the route
   * as dictated by netlify identity's communication with us via hashes
   */
  var routes = /(confirmation|invite|recovery|email_change)_token=([^&]+)/;
  var errorRoute = /error=access_denied&error_description=403/;
  var accessTokenRoute = /access_token=/;
  var confirmationRoute = /confirmation_token=/;
  function runRoutes(gotrue, setUser, remember) {
    if (remember === void 0) {
      remember = true;
    }

    var hash = (document.location.hash || '').replace(/^#\/?/, '');
    if (!hash) return; // early terminate if no hash

    var m = hash.match(routes);

    if (m) {
      // store.verifyToken(m[1], m[2]);
      document.location.hash = '';
    }

    var em = hash.match(errorRoute);

    if (em) {
      // store.openModal("signup");
      document.location.hash = '';
    }

    var params = {};
    hash.split('&').forEach(function (pair) {
      var _pair$split = pair.split('='),
          key = _pair$split[0],
          value = _pair$split[1];

      params[key] = value;
    });
    var am = hash.match(accessTokenRoute);

    if (am) {
      if (!!document && params['access_token']) {
        document.cookie = "nf_jwt=" + params['access_token'];
      }

      document.location.hash = ''; // store.openModal("login");
      // store.completeExternalLogin(params);

      gotrue.createUser(params, remember).then(setUser)["catch"](console.error);
    }

    var cm = hash.match(confirmationRoute);

    if (cm) {
      document.location.hash = ''; // store.openModal("login");
      // store.completeExternalLogin(params);

      gotrue.confirm(params['confirmation_token']).then(setUser)["catch"](console.error);
    }
  }

  var defaultSettings = {
    autoconfirm: false,
    disable_signup: false,
    external: {
      bitbucket: false,
      email: true,
      facebook: false,
      github: false,
      gitlab: false,
      google: false
    }
  };

  var _createCtx =
  /*#__PURE__*/
  createCtx(),
      _useIdentityContext = _createCtx[0],
      _IdentityCtxProvider = _createCtx[1];

  var useIdentityContext = _useIdentityContext; // we dont want to expose _IdentityCtxProvider

  /** most people should use this provider directly */

  function IdentityContextProvider(_ref) {
    var url = _ref.url,
        children = _ref.children,
        _ref$onAuthChange = _ref.onAuthChange,
        onAuthChange = _ref$onAuthChange === void 0 ? function () {} : _ref$onAuthChange;

    /******** SETUP */
    if (!url || !validateUrl(url)) {
      // just a safety check in case a JS user tries to skip this
      throw new Error('invalid netlify instance URL: ' + url + '. Please check the docs for proper usage or file an issue.');
    }

    var identity = useNetlifyIdentity(url, onAuthChange);
    return React.createElement(_IdentityCtxProvider, {
      value: identity
    }, children);
  }
  /** some people may want to use this as a hook and bring their own contexts */

  function useNetlifyIdentity(url, onAuthChange, enableRunRoutes) {
    if (onAuthChange === void 0) {
      onAuthChange = function onAuthChange() {};
    }

    if (enableRunRoutes === void 0) {
      enableRunRoutes = true;
    }

    var goTrueInstance = React.useMemo(function () {
      return new GoTrue({
        APIUrl: url + "/.netlify/identity",
        setCookie: true
      });
    }, [url]);

    var _React$useState = React.useState(goTrueInstance.currentUser() || undefined),
        user = _React$useState[0],
        setUser = _React$useState[1];

    var _setUser = function _setUser(_user) {
      setUser(_user);
      onAuthChange(_user); // if someone's subscribed to auth changes, let 'em know

      return _user; // so that we can continue chaining
    };

    React.useEffect(function () {
      if (enableRunRoutes) {
        runRoutes(goTrueInstance, _setUser);
      }
    }, []);

    var loginProvider = function loginProvider(provider) {
      var url = goTrueInstance.loginExternalUrl(provider);
      window.location.href = url;
    };

    var acceptInviteExternalUrl = function acceptInviteExternalUrl(provider, token) {
      return goTrueInstance.acceptInviteExternalUrl(provider, token);
    };

    var _settings = goTrueInstance.settings.bind(goTrueInstance);

    var _React$useState2 = React.useState(defaultSettings),
        settings = _React$useState2[0],
        setSettings = _React$useState2[1];

    React.useEffect(function () {
      _settings().then(function (x) {
        return setSettings(x);
      });
    }, []);
    /******* email auth */

    var signupUser = function signupUser(email, password, data) {
      return goTrueInstance.signup(email, password, data).then(_setUser);
    }; // TODO: make setUser optional?


    var loginUser = function loginUser(email, password, remember) {
      if (remember === void 0) {
        remember = true;
      }

      return goTrueInstance.login(email, password, remember).then(_setUser);
    };

    var requestPasswordRecovery = function requestPasswordRecovery(email) {
      return goTrueInstance.requestPasswordRecovery(email);
    };

    var recoverAccount = function recoverAccount(token, remember) {
      return goTrueInstance.recover(token, remember);
    };

    var updateUser = function updateUser(fields) {
      if (user == null) {
        throw new Error('No current user found - are you logged in?');
      } else {
        return user.update(fields) // e.g. { data: { email: "example@example.com", password: "password" } }
        .then(_setUser);
      }
    };

    var getFreshJWT = function getFreshJWT() {
      if (!user) throw new Error('No current user found - are you logged in?');
      return user.jwt();
    };

    var logoutUser = function logoutUser() {
      if (!user) throw new Error('No current user found - are you logged in?');
      return user.logout().then(function () {
        return _setUser(undefined);
      });
    };

    var genericAuthedFetch = function genericAuthedFetch(method) {
      return function (endpoint, obj) {
        if (obj === void 0) {
          obj = {};
        }

        if (!user || !user.token || !user.token.access_token) throw new Error('no user token found');
        var defaultObj = {
          headers: {
            Accept: 'application/json',
            'Content-Type': 'application/json',
            Authorization: 'Bearer ' + user.token.access_token
          }
        };
        var finalObj = Object.assign(defaultObj, {
          method: method
        }, obj);
        return fetch(endpoint, finalObj).then(function (res) {
          return finalObj.headers['Content-Type'] === 'application/json' ? res.json() : res;
        });
      };
    };

    var authedFetch = {
      get: genericAuthedFetch('GET'),
      post: genericAuthedFetch('POST'),
      put: genericAuthedFetch('PUT'),
      "delete": genericAuthedFetch('DELETE')
    };
    /******* hook API */

    return {
      user: user,

      /** not meant for normal use! you should mostly use one of the other exported methods to update the user instance */
      setUser: setUser,
      isConfirmedUser: !!(user && user.confirmed_at),
      isLoggedIn: !!user,
      signupUser: signupUser,
      loginUser: loginUser,
      logoutUser: logoutUser,
      requestPasswordRecovery: requestPasswordRecovery,
      recoverAccount: recoverAccount,
      updateUser: updateUser,
      getFreshJWT: getFreshJWT,
      authedFetch: authedFetch,
      _goTrueInstance: goTrueInstance,
      _url: url,
      loginProvider: loginProvider,
      acceptInviteExternalUrl: acceptInviteExternalUrl,
      settings: settings
    };
  }
  /**
   *
   *
   * Utils
   *
   */

  function validateUrl(value) {
    return /^(?:(?:(?:https?|ftp):)?\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,})))(?::\d{2,5})?(?:[/?#]\S*)?$/i.test(value);
  } // lazy initialize contexts without providing a Nullable type upfront


  function createCtx() {
    var ctx = React.createContext(undefined);

    function useCtx() {
      var c = React.useContext(ctx);
      if (!c) throw new Error('useCtx must be inside a Provider with a value');
      return c;
    }

    return [useCtx, ctx.Provider];
  } // // Deprecated for now
  // interface NIProps {
  //   children: any
  //   url: string
  //   onAuthChange?: authChangeParam
  // }
  // export default function NetlifyIdentity({ children, url, onAuthChange }: NIProps) {
  //   return children(useNetlifyIdentity(url, onAuthChange))
  // }

  exports.IdentityContextProvider = IdentityContextProvider;
  exports.useIdentityContext = useIdentityContext;
  exports.useNetlifyIdentity = useNetlifyIdentity;

}));
//# sourceMappingURL=react-netlify-identity.umd.development.js.map
